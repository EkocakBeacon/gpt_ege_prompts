Act as a code interpreter and run the following code. Explain the result and any discrepancy.
"""
Antwerp Unmooring Fee Calculator
--------------------------------

Rules mirror those for mooring but with UNMOORING_TARIFFS and FRACTION_RATES['unmooring']=109.
Steps:
1) Base tariff by LOA using UNMOORING_TARIFFS. If LOA>400m add 5m segments at 109 EUR.
2) Time supplement: Sunday +50%, else night (19:00–07:00) +25%, else 0.
3) Location supplement: +30% if location contains "riverquay".
4) Delay supplement: if delay>45min → 50% of (Base+TimeSuppl+LocSuppl) per started hour beyond 45min.
5) Reductions: -25% for second call; -50% for short movement.
6) Cancellation: +50% of Base if cancelled.
7) Total = Base + TimeSuppl + LocSuppl + DelaySuppl + CancelFee - Reductions.
"""

from __future__ import annotations
import argparse
import datetime as dt
import json
import math
from typing import List, Tuple

UNMOORING_TARIFFS: List[Tuple[float, float, float]] = [
  (0, 80.00, 113),(80.01, 90.00, 147),(90.01,100.00,151),(100.01,110.00,203),
  (110.01,120.00,211),(120.01,130.00,241),(130.01,138.00,253),(138.01,146.00,268),
  (146.01,152.00,300),(152.01,157.00,342),(157.01,160.00,353),(160.01,167.50,375),
  (167.51,175.00,466),(175.01,182.50,513),(182.51,190.00,546),(190.01,197.50,570),
  (197.51,205.00,609),(205.01,212.50,624),(212.51,220.00,668),(220.01,227.50,701),
  (227.51,235.00,807),(235.01,242.50,899),(242.51,250.00,938),(250.01,257.50,968),
  (257.51,265.00,1008),(265.01,272.50,1044),(272.51,280.00,1072),(280.01,287.50,1111),
  (287.51,295.00,1188),(295.01,302.50,1369),(302.51,310.00,1434),(310.01,317.50,1585),
  (317.51,325.00,1717),(325.01,330.00,1927),(330.01,335.00,2136),(335.01,340.00,2344),
  (340.01,345.00,2446),(345.01,350.00,2542),(350.01,355.00,2563),(355.01,360.00,2682),
  (360.01,365.00,2795),(365.01,370.00,2909),(370.01,375.00,3017),(375.01,380.00,3126),
  (380.01,385.00,3235),(385.01,390.00,3341),(390.01,395.00,3450),(395.01,400.00,3559)
]

FRACTION_RATES = {"unmooring": 109}


def _find_base(loa: float) -> float:
    for lo, hi, tariff in UNMOORING_TARIFFS:
        if lo <= loa <= hi:
            return tariff
    base_400 = UNMOORING_TARIFFS[-1][2]
    extra_segments = math.ceil((loa - 400) / 5)
    return base_400 + extra_segments * FRACTION_RATES["unmooring"]


def calculate_unmooring(
    *,
    loa_m: float,
    service_time: dt.datetime,
    location: str,
    delay_minutes: float | None = None,
    is_second_call: bool = False,
    is_short_movement: bool = False,
    is_cancelled: bool = False,
    billed_amount_eur: float | None = None,
) -> tuple[str, dict]:
    base = _find_base(loa_m)

    if service_time.weekday() == 6:
        time_suppl = base * 0.50
    elif service_time.hour >= 19 or service_time.hour < 7:
        time_suppl = base * 0.25
    else:
        time_suppl = 0.0

    loc_suppl = base * 0.30 if "riverquay" in location.lower() else 0.0

    delay_suppl = 0.0
    if delay_minutes and delay_minutes > 45:
        hours_delayed = math.ceil((delay_minutes - 45) / 60)
        delay_suppl = (base + time_suppl + loc_suppl) * 0.50 * hours_delayed

    reductions = 0.0
    if is_second_call:
        reductions += base * 0.25
    if is_short_movement:
        reductions += base * 0.50

    cancel_fee = base * 0.50 if is_cancelled else 0.0

    total = base + time_suppl + loc_suppl + delay_suppl + cancel_fee - reductions
    total = round(total, 2)

    variance = None
    pass_2pct = None
    if billed_amount_eur is not None:
        variance = abs(total - billed_amount_eur) / total
        pass_2pct = variance <= 0.02

    breakdown = (
        f"Base={base:.2f}, TimeSuppl={time_suppl:.2f}, LocSuppl={loc_suppl:.2f}, "
        f"DelaySuppl={delay_suppl:.2f}, Reductions={reductions:.2f}, CancelFee={cancel_fee:.2f}, Total={total:.2f}"
    )

    summary = {
        "inputs": {
            "loa_m": loa_m,
            "service_time": service_time.isoformat(),
            "location": location,
            "delay_minutes": delay_minutes,
            "is_second_call": is_second_call,
            "is_short_movement": is_short_movement,
            "is_cancelled": is_cancelled,
            "billed_amount_eur": billed_amount_eur,
        },
        "computed": {
            "base_eur": round(base, 2),
            "time_suppl_eur": round(time_suppl, 2),
            "loc_suppl_eur": round(loc_suppl, 2),
            "delay_suppl_eur": round(delay_suppl, 2),
            "reductions_eur": round(reductions, 2),
            "cancel_fee_eur": round(cancel_fee, 2),
            "total_eur": total,
        },
        "validation": {
            "variance_pct": variance,
            "pass_within_2pct": pass_2pct,
        },
    }

    return breakdown, summary


def _cli() -> None:
    p = argparse.ArgumentParser(description="Antwerp unmooring calculator")
    p.add_argument("--loa", type=float, required=True)
    p.add_argument("--service-time", type=str, required=True, help="ISO datetime")
    p.add_argument("--location", type=str, required=True)
    p.add_argument("--delay-minutes", type=float)
    p.add_argument("--second-call", action="store_true")
    p.add_argument("--short-movement", action="store_true")
    p.add_argument("--cancelled", action="store_true")
    p.add_argument("--billed", type=float)
    args = p.parse_args()

    st = dt.datetime.fromisoformat(args.service_time)
    breakdown, summary = calculate_unmooring(
        loa_m=args.loa,
        service_time=st,
        location=args.location,
        delay_minutes=args.delay_minutes,
        is_second_call=args.second_call,
        is_short_movement=args.short_movement,
        is_cancelled=args.cancelled,
        billed_amount_eur=args.billed,
    )

    print("Calculated Unmooring:", summary["computed"]["total_eur"], "EUR")
    print(breakdown)
    print("\nJSON Summary:\n" + json.dumps(summary, indent=2))


if __name__ == "__main__":
    _cli()

