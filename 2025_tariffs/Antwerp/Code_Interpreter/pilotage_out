The vessel has the following particulars:
Name: {{{vessel.name}}}
LOA: {{{vessel.particulars.loa}}}
Beam: {{{vessel.particulars.boa}}}
GT: {{{vessel.particulars.grossTonnage}}}
Reduced GT: {{{vessel.particulars.reducedGrossTonnage}}}
Net Tonnage (NT): {{{vessel.particulars.netTonnage}}}
NRT: {{{vessel.nrt}}}
Summer Deadweight: {{{vessel.summerDwt}}}
Winter Deadweight: {{{vessel.winterDwt}}}
Length between perpendiculars: {{{vessel.particulars.lbp}}}
Type: {{{vessel.type}}}
ESI score: {{{vessel.esiScore}}}
Green Award score: {{{vessel.greenAward}}}

Port call data:
Draft in: {{{portCall.prospects.currentProspects.arrival.details.draftAft}}}
Draft out: {{{portCall.prospects.currentProspects.departureDraftAft}}}
Tugs in: {{{portCall.prospects.currentProspects.arrival.details.tugs}}}
Tugs out: {{{portCall.prospects.currentProspects.departure.details.tugs}}}
Cargoes:
{{#portCall.prospects.currentProspects.terminals}}
{{#cargoes}}
* {{cargo.operation.label}} {{cargo.quantity}} {{cargo.quantityMetricLabel}} of {{cargo.cargo.name}}
{{/cargoes}}
{{/portCall.prospects.currentProspects.terminals}}

Terminal names: 
{{#portCall.prospects.currentProspects.terminals}}
{{#terminal}}
*{{name}}
{{/terminal}}
{{/portCall.prospects.currentProspects.terminals}}

Local arrival time: {{{portCall.ata}}}
Local berthing time: {{{portCall.atb}}}
Local completion of cargo operation time: {{{portCall.atc}}}
Local departure time: {{{portCall.atd}}}

The amount that was invoiced to the vessel was: {{{line.currency}}} {{{line.localAmount}}}. It was for {{{line.line.name}}}.

The invoice image(s) are attached.  
Calculation instructions: {{{lineInstructions}}}

Act as a code interpreter and execute the following code. Use the injected values above and only read the invoice if a value is missing (capture it in brackets with units). Show the raw code output first, then provide a human-readable explanation and any discrepancy.
"""
Antwerp Pilotage-Out (Block-Size) Fee Calculator
================================================

Goal
----
Calculate the Antwerp pilotage-out fee using the block-size method with exact tariffs.

Data usage rule (priority):
1) Use provided variables first.
2) If missing, try to parse from invoice text.
3) If still missing, mark as "not provided".

BAF must come from the invoice; if not found we compute with BAF=0 and warn.

Block size uses draught in **meters**:
  block_size = length_m * breadth_m * draught_m
If invoice text provides draught in dm, convert dm→m.
"""

from __future__ import annotations
import argparse
import json
import math
import os
import re
import importlib.util
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any

# ---------------------------------------------------------------------------
# Reuse tariff table and helpers from pilotage_in
# ---------------------------------------------------------------------------

_spec = importlib.util.spec_from_file_location(
    "pilotage_in", Path(__file__).with_name("pilotage_in")
)
_pi = importlib.util.module_from_spec(_spec)
_spec.loader.exec_module(_pi)  # type: ignore

ALLOWED_ROUTE_KEYS = _pi.ALLOWED_ROUTE_KEYS
TARIFF_TABLE = _pi.TARIFF_TABLE
_parse_number = _pi._parse_number
parse_invoice_text = _pi.parse_invoice_text


def calculate_pilotage_out(
    *,
    length_m: float | None,
    breadth_m: float | None,
    max_summer_draught_m: float | None,
    routes: List[str] | None,
    baf_percentage: float | None,
    cancellation_fee: float | None,
    delay_fee: float | None,
    storm_pilot_fee: float | None,
    special_case_fee: float | None,
    custom_volume_discount: float | None,
    invoice_text: str | None = None,
) -> Tuple[str, Dict]:
    parsed = parse_invoice_text(invoice_text or "")

    length_m = float(length_m) if length_m is not None else None
    breadth_m = float(breadth_m) if breadth_m is not None else None
    draught_m = float(max_summer_draught_m) if max_summer_draught_m is not None else parsed.get("draught_m")
    draught_dm_explicit = parsed.get("draught_dm_explicit")
    routes = routes or []

    baf_percentage = (
        baf_percentage if baf_percentage is not None else parsed.get("baf_percentage")
    )
    cancellation_fee = cancellation_fee if cancellation_fee is not None else parsed.get("cancellation_fee", 0.0)
    delay_fee = delay_fee if delay_fee is not None else parsed.get("delay_fee", 0.0)
    storm_pilot_fee = storm_pilot_fee if storm_pilot_fee is not None else parsed.get("storm_pilot_fee", 0.0)
    special_case_fee = special_case_fee if special_case_fee is not None else parsed.get("special_case_fee", 0.0)
    custom_volume_discount = custom_volume_discount or 0.0

    warnings: List[str] = []
    notes: List[str] = []

    if draught_m is None and draught_dm_explicit is not None:
        draught_m = float(draught_dm_explicit) / 10.0
        notes.append("Draught from invoice in dm; converted to meters by ÷10.")

    if length_m is None or breadth_m is None or draught_m is None or not routes:
        raise ValueError("length_m, breadth_m, draught_m and routes are required")

    block_size = length_m * breadth_m * draught_m

    # Determine base fees per route
    route_base_fees: List[Dict[str, Any]] = []
    for route in routes:
        if route not in ALLOWED_ROUTE_KEYS:
            raise ValueError(f"Unknown route: {route}")
        row = TARIFF_TABLE[-1]
        for r in TARIFF_TABLE:
            if r["min"] <= block_size <= r["max"]:
                row = r
                break
        fee = row[route]
        route_base_fees.append({
            "route": route,
            "range_min": row["min"],
            "range_max": row["max"],
            "base_fee_eur": fee,
        })

    total_base_fee = sum(r["base_fee_eur"] for r in route_base_fees)

    additional_fees_total = (cancellation_fee or 0.0) + (delay_fee or 0.0) + (storm_pilot_fee or 0.0) + (special_case_fee or 0.0)
    volume_discount_value = total_base_fee * (custom_volume_discount / 100.0)
    baf_pct_used = baf_percentage if baf_percentage is not None else 0.0
    if baf_percentage is None:
        warnings.append("BAF percentage missing; treated as 0")
    baf_amount = total_base_fee * (baf_pct_used / 100.0)

    final_amount = total_base_fee + additional_fees_total - volume_discount_value + baf_amount

    def money(x: float) -> str:
        return f"€{x:,.2f}"

    lines = []
    lines.append("Antwerp Pilotage-Out (Block-Size) – Calculation Breakdown")
    lines.append("")
    lines.append(f"1) Block size = {length_m} × {breadth_m} × {draught_m} = {block_size:,.2f}")
    lines.append("2) Base fee per route:")
    for r in route_base_fees:
        lines.append(
            f"   - {r['route']}: bracket [{r['range_min']:,}-{r['range_max']:,}] -> {money(r['base_fee_eur'])}"
        )
    lines.append(f"   total_base_fee = {money(total_base_fee)}")
    lines.append(
        f"3) Additional fees = {money(cancellation_fee or 0)} (cancellation) + {money(delay_fee or 0)} (delay) + "
        f"{money(storm_pilot_fee or 0)} (storm pilot) + {money(special_case_fee or 0)} (special) = {money(additional_fees_total)}"
    )
    lines.append(f"4) Volume discount = total_base_fee × {custom_volume_discount:.2f}% = {money(volume_discount_value)}")
    lines.append(f"5) BAF = total_base_fee × {baf_pct_used:.2f}% = {money(baf_amount)}")
    lines.append(
        f"6) Final amount = {money(total_base_fee)} + {money(additional_fees_total)} - {money(volume_discount_value)} + {money(baf_amount)} = {money(final_amount)}"
    )
    if warnings:
        lines.append("")
        lines.append("WARNINGS:")
        for w in warnings:
            lines.append(f"- {w}")
    breakdown = "\n".join(lines)

    summary = {
        "inputs": {
            "length_m": length_m,
            "breadth_m": breadth_m,
            "draught_m": draught_m,
            "routes": routes,
            "baf_percentage": baf_percentage if baf_percentage is not None else "not provided",
            "cancellation_fee": cancellation_fee or 0.0,
            "delay_fee": delay_fee or 0.0,
            "storm_pilot_fee": storm_pilot_fee or 0.0,
            "special_case_fee": special_case_fee or 0.0,
            "custom_volume_discount": custom_volume_discount or 0.0,
        },
        "computed": {
            "block_size": round(block_size, 2),
            "route_base_fees": route_base_fees,
            "total_base_fee_eur": round(total_base_fee, 2),
            "additional_fees_total_eur": round(additional_fees_total, 2),
            "volume_discount_value_eur": round(volume_discount_value, 2),
            "baf_amount_eur": round(baf_amount, 2),
            "final_amount_eur": round(final_amount, 2),
        },
        "warnings": warnings,
        "notes": notes,
    }

    return breakdown, summary


def _cli() -> None:
    p = argparse.ArgumentParser(description="Antwerp Pilotage-Out fee calculator")
    p.add_argument("--length-m", type=float)
    p.add_argument("--breadth-m", type=float)
    p.add_argument("--draught-m", type=float)
    p.add_argument("--route", action="append")
    p.add_argument("--baf-percentage", type=float)
    p.add_argument("--cancellation-fee", type=float, default=0.0)
    p.add_argument("--delay-fee", type=float, default=0.0)
    p.add_argument("--storm-pilot-fee", type=float, default=0.0)
    p.add_argument("--special-case-fee", type=float, default=0.0)
    p.add_argument("--custom-volume-discount", type=float, default=0.0)
    p.add_argument("--invoice-text", type=str)
    args = p.parse_args()

    breakdown, summary = calculate_pilotage_out(
        length_m=args.length_m,
        breadth_m=args.breadth_m,
        max_summer_draught_m=args.draught_m,
        routes=args.route,
        baf_percentage=args.baf_percentage,
        cancellation_fee=args.cancellation_fee,
        delay_fee=args.delay_fee,
        storm_pilot_fee=args.storm_pilot_fee,
        special_case_fee=args.special_case_fee,
        custom_volume_discount=args.custom_volume_discount,
        invoice_text=args.invoice_text,
    )

    print(breakdown)
    print("\nJSON Summary:\n" + json.dumps(summary, indent=2))


if __name__ == "__main__":
    _cli()

